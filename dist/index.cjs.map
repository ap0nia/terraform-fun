{"version":3,"sources":["../src/index.ts","../src/cdktf/project.ts","../src/utils/directories.ts"],"sourcesContent":["import { Construct } from \"constructs\";\nimport aws_s3 from 'aws-cdk-lib/aws-s3';\nimport { App, TerraformStack } from \"cdktf\";\nimport { AwsTerraformAdapter, provider } from \"@cdktf/aws-cdk\";\nimport { CdktfProject } from './cdktf/project.js'\n\nexport class HelloCdkStack extends TerraformStack {\n  constructor(scope: Construct, name: string) {\n    super(scope, name);\n\n    new provider.AwsProvider(this, 'aws', { region: 'us-east-1' })\n\n    const awsAdapter = new AwsTerraformAdapter(this, \"adapter\");\n\n    new aws_s3.Bucket(awsAdapter, 'MyFirstBucket', {\n      bucketName: 'my-first-bucket-in-terraform-is-so-epic',\n      versioned: true,\n    });\n  }\n}\n\nasync function synthFn() {\n  const app = new App();\n\n  new HelloCdkStack(app, \"learn-cdktf-aws\");\n\n  app.synth();\n}\n\nasync function start() {\n  const project = new CdktfProject({ synthFn });\n\n  await project.deploy()\n\n  // await project.destroy()\n}\n\nstart()\n","import fs from 'node:fs'\nimport path from 'node:path'\nimport { Manifest, type StackManifest, type TerraformStackMetadata } from \"cdktf\";\nimport { Errors, ensureAllSettledBeforeThrowing } from '@cdktf/commons'\nimport {\n  getMultipleStacks,\n  getStackWithNoUnmetDependencies,\n  checkIfAllDependantsAreIncluded,\n  checkIfAllDependenciesAreIncluded,\n  getStackWithNoUnmetDependants,\n  findAllNestedDependantStacks,\n} from '@cdktf/cli-core/src/lib/helpers/stack-helpers.js'\nimport { CdktfStack } from '@cdktf/cli-core';\nimport { getDirectories } from '../utils/directories.js';\n\nfunction noop() { }\n\ninterface SynthesizedStack extends StackManifest {\n  content: string;\n}\n\ninterface ManifestJson {\n  version: string;\n  stacks: Record<string, StackManifest>;\n}\n\ninterface SynthesizedStackMetadata {\n  \"//\"?: Record<string, TerraformStackMetadata>\n}\n\ntype ExecutionMethod = 'deploy' | 'destroy'\n\ntype CdktfStackMiddleware = () => Promise<CdktfStack | undefined>\n\nconst CONFIG_DEFAULTS = {\n  output: \"cdktf.out\",\n  codeMakerOutput: \".gen\",\n}\n\nexport type MultipleStackOptions = {\n  stackNames?: string[];\n};\n\nexport type AutoApproveOptions = {\n  autoApprove?: boolean;\n};\n\nexport type MutationOptions = MultipleStackOptions & AutoApproveOptions & {\n  refreshOnly?: boolean;\n  ignoreMissingStackDependencies?: boolean;\n  parallelism?: number;\n  terraformParallelism?: number;\n  vars?: string[];\n  varFiles?: string[];\n  noColor?: boolean;\n  migrateState?: boolean;\n};\n\ninterface CdktfProjectOptions {\n  /**\n   * A function that will run and generate an output JSON.\n   */\n  synthFn?: () => unknown | Promise<unknown>;\n}\n\n/**\n * A simplfied, minimal adaptation of the official class.\n * {@link https://github.com/hashicorp/terraform-cdk/blob/main/packages/%40cdktf/cli-core/src/lib/cdktf-project.ts}\n */\nexport class CdktfProject {\n  public stacksToRun: CdktfStack[] = [];\n\n  private stopAllStacksThatCanNotRunWithout: (stackName: string) => void = noop\n\n  public hardAbort: () => void;\n\n  private abortSignal: AbortSignal;\n\n  private synthFn: () => unknown | Promise<unknown>;\n\n  constructor(options: CdktfProjectOptions = {}) {\n    this.synthFn = options.synthFn ?? noop;\n\n    const ac = new AbortController();\n    this.abortSignal = ac.signal;\n    this.hardAbort = ac.abort.bind(ac);\n  }\n\n  async synth(opts = CONFIG_DEFAULTS) {\n    await this.synthFn()\n\n    if (!(fs.existsSync(path.join(opts.output, Manifest.fileName)))) {\n      throw new Error(\n        `ERROR: synthesis failed, because app was expected to call 'synth()', but didn't. Thus \"${opts.output}/${Manifest.fileName}\"  was not created.`\n      );\n    }\n\n    const manifest: ManifestJson = JSON.parse(\n      fs.readFileSync(path.join(opts.output, Manifest.fileName)).toString()\n    );\n\n    const stacks: SynthesizedStack[] = Object.keys(manifest.stacks).map(stackName => {\n      const stack = manifest.stacks[stackName];\n\n      const filePath = path.join(opts.output, stack.synthesizedStackPath);\n\n      const jsonContent: SynthesizedStackMetadata = JSON.parse(\n        fs.readFileSync(filePath).toString()\n      );\n\n      return {\n        ...stack,\n        workingDirectory: path.join(opts.output, stack.workingDirectory),\n        content: JSON.stringify(jsonContent, null, 2),\n      }\n    })\n\n    if (stacks.length === 0) {\n      console.error(\"ERROR: No Terraform code synthesized.\");\n    } else {\n      console.log(\"Synthesized Terraform code for the following stacks: \", stacks);\n    }\n\n    const stackNames = stacks.map((s) => s.name);\n\n    const existingDirectories = getDirectories(path.join(opts.output, Manifest.stacksFolder));\n\n    const orphanedDirectories = existingDirectories.filter(\n      (e) => !stackNames.includes(path.basename(e))\n    );\n\n    for (const orphanedDirectory of orphanedDirectories) {\n      fs.rmSync(orphanedDirectory, { recursive: true });\n    }\n\n    return stacks\n  }\n\n  async deploy(opts: MutationOptions = {}) {\n    const stacks = await this.synth();\n\n    const stacksToRun = getMultipleStacks(stacks, opts.stackNames, \"deploy\");\n\n    if (!opts.ignoreMissingStackDependencies) {\n      checkIfAllDependenciesAreIncluded(stacksToRun);\n    }\n\n    const abortController = new AbortController();\n\n    this.stacksToRun = stacksToRun.map((stack) => {\n      return new CdktfStack({\n        ...opts,\n        onUpdate(update) {\n          console.log({ update })\n          if (update.type === 'waiting for stack approval') {\n            update.approve()\n          }\n        },\n        abortSignal: abortController.signal,\n        stack,\n      });\n    });\n\n    this.stopAllStacksThatCanNotRunWithout = (stackName: string) => {\n      findAllNestedDependantStacks(this.stacksToRun, stackName).forEach((stack) => stack.stop());\n    };\n\n    const next = opts.ignoreMissingStackDependencies\n      ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.isPending)[0])\n      : () => getStackWithNoUnmetDependencies(this.stacksToRun);\n\n\n    await this.execute(\"deploy\", next, opts);\n\n    const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);\n\n    if (unprocessedStacks.length > 0) {\n      throw Errors.External(\n        `Some stacks failed to deploy: ${unprocessedStacks\n          .map((s) => s.stack.name)\n          .join(\", \")}. Please check the logs for more information.`\n      );\n    }\n  }\n\n  public async destroy(opts: MutationOptions = {}) {\n    const stacks = await this.synth();\n\n    const stacksToRun = getMultipleStacks(stacks, opts.stackNames, \"destroy\");\n\n    if (!opts.ignoreMissingStackDependencies) {\n      checkIfAllDependantsAreIncluded(stacksToRun, stacks);\n    }\n\n    this.stopAllStacksThatCanNotRunWithout = (stackName: string) => {\n      const stackExecutor = this.stacksToRun.find((s) => s.stack.name === stackName);\n\n      if (!stackExecutor) {\n        throw Errors.Internal(\n          `Could not find stack \"${stackName}\" that was stopped`\n        );\n      }\n\n      stackExecutor.stack.dependencies.forEach((dependant) => {\n        this.stopAllStacksThatCanNotRunWithout(dependant);\n\n        const dependantStack = this.stacksToRun.find(\n          (s) => s.stack.name === dependant\n        );\n\n        if (!dependantStack) {\n          throw Errors.Internal(\n            `Could not find stack \"${dependant}\" that was stopped`\n          );\n        }\n\n        dependantStack.stop();\n      });\n    };\n\n    this.stacksToRun = stacksToRun.map((stack) =>\n      this.getStackExecutor(stack, opts)\n    );\n\n    const next = opts.ignoreMissingStackDependencies\n      ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.currentState !== \"done\")[0])\n      : () => getStackWithNoUnmetDependants(this.stacksToRun);\n\n    await this.execute(\"destroy\", next, opts);\n\n    const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);\n\n    if (unprocessedStacks.length > 0) {\n      throw Errors.External(\n        `Some stacks failed to destroy: ${unprocessedStacks\n          .map((s) => s.stack.name)\n          .join(\", \")}. Please check the logs for more information.`\n      );\n    }\n  }\n\n  async execute(method: ExecutionMethod, next: CdktfStackMiddleware, opts: MutationOptions) {\n    // We only support refresh only on deploy, a bit of a leaky abstraction here\n    if (opts.refreshOnly && method !== \"deploy\") {\n      throw Errors.Internal(`Refresh only is only supported on deploy`);\n    }\n\n    const maxParallelRuns = !opts.parallelism || opts.parallelism < 0 ? Infinity : opts.parallelism;\n\n    const allExecutions: Promise<unknown>[] = [];\n\n    await this.initializeStacksToRunInSerial(opts.noColor);\n\n    while (this.stacksToRun.filter((stack) => stack.isPending).length > 0) {\n      const runningStacks = this.stacksToRun.filter((stack) => stack.isRunning);\n\n      if (runningStacks.length >= maxParallelRuns) {\n        await Promise.race(runningStacks.map((s) => s.currentWorkPromise));\n        continue;\n      }\n\n      try {\n        const nextRunningExecutor = await next();\n\n        if (!nextRunningExecutor) {\n          // In this case we have no pending stacks, but we also can not find a new executor\n          break;\n        }\n\n        const promise = method === \"deploy\"\n          ? nextRunningExecutor.deploy(opts)\n          : nextRunningExecutor.destroy(opts);\n\n        allExecutions.push(promise);\n      } catch (e) {\n        // await next() threw an error because a stack failed to apply/destroy\n        // wait for all other currently running stacks to complete before propagating that error\n        console.debug(\"Encountered an error while awaiting stack to finish\", e);\n        const openStacks = this.stacksToRun.filter((ex) => ex.currentWorkPromise);\n        console.debug(\"Waiting for still running stacks to finish:\", openStacks);\n        await Promise.allSettled(openStacks.map((ex) => ex.currentWorkPromise));\n        console.debug(\"Done waiting for still running stacks. All pending work finished\");\n        throw e;\n      }\n    }\n\n    // We end the loop when all stacks are started, now we need to wait for them to be done.\n    // We wait for all work to finish even if one of the promises threw an error.\n    await ensureAllSettledBeforeThrowing(Promise.all(allExecutions), allExecutions);\n  }\n\n  public getStackExecutor(stack: SynthesizedStack, opts: AutoApproveOptions = {}) {\n    return new CdktfStack({\n      ...opts,\n      stack,\n      onUpdate(update) {\n        console.log({ update })\n        if (update.type === 'waiting for stack approval') {\n          update.approve()\n        }\n      },\n      abortSignal: this.abortSignal,\n    });\n  }\n\n  // Serially run terraform init to prohibit text file busy errors for the cache files\n  private async initializeStacksToRunInSerial(noColor?: boolean): Promise<void> {\n    await Promise.all(this.stacksToRun.map((stack) => stack.initalizeTerraform(noColor)));\n  }\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nexport function getDirectories(source: string) {\n  return fs.existsSync(source)\n    ? fs\n      .readdirSync(source)\n      .map((name) => path.join(source, name))\n      .filter(source => fs.lstatSync(source).isDirectory())\n    : [];\n};\n\n"],"mappings":"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","names":["src_exports","__export","HelloCdkStack","__toCommonJS","import_aws_s3","import_cdktf","import_aws_cdk","import_node_fs","import_node_path","import_cdktf","import_commons","import_stack_helpers","import_cli_core","import_node_fs","import_node_path","getDirectories","source","fs","name","path","noop","CONFIG_DEFAULTS","CdktfProject","options","ac","opts","fs","path","manifest","stacks","stackName","stack","filePath","jsonContent","stackNames","s","orphanedDirectories","getDirectories","orphanedDirectory","stacksToRun","abortController","update","next","unprocessedStacks","executor","stackExecutor","dependant","dependantStack","method","maxParallelRuns","allExecutions","runningStacks","nextRunningExecutor","promise","openStacks","ex","noColor","HelloCdkStack","scope","name","awsAdapter","aws_s3","synthFn","app","start","CdktfProject"]}