var C=Object.create;var m=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var O=Object.getOwnPropertyNames;var N=Object.getPrototypeOf,E=Object.prototype.hasOwnProperty;var j=(s,t)=>{for(var n in t)m(s,n,{get:t[n],enumerable:!0})},x=(s,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of O(t))!E.call(s,r)&&r!==n&&m(s,r,{get:()=>t[r],enumerable:!(o=D(t,r))||o.enumerable});return s};var d=(s,t,n)=>(n=s!=null?C(N(s)):{},x(t||!s||!s.__esModule?m(n,"default",{value:s,enumerable:!0}):n,s)),F=s=>x(m({},"__esModule",{value:!0}),s);var $={};j($,{HelloCdkStack:()=>S});module.exports=F($);var v=d(require("aws-cdk-lib/aws-s3"),1),w=require("cdktf"),R=require("@cdktf/aws-cdk");var f=d(require("fs"),1),k=d(require("path"),1),h=require("cdktf"),u=require("@cdktf/commons"),c=require("@cdktf/cli-core/src/lib/helpers/stack-helpers.js"),T=require("@cdktf/cli-core");var g=d(require("fs"),1),A=d(require("path"),1);function M(s){return g.default.existsSync(s)?g.default.readdirSync(s).map(t=>A.default.join(s,t)).filter(t=>g.default.lstatSync(t).isDirectory()):[]}function P(){}var z={output:"cdktf.out",codeMakerOutput:".gen"},y=class{stacksToRun=[];stopAllStacksThatCanNotRunWithout=P;hardAbort;abortSignal;synthFn;constructor(t={}){this.synthFn=t.synthFn??P;let n=new AbortController;this.abortSignal=n.signal,this.hardAbort=n.abort.bind(n)}async synth(t=z){if(await this.synthFn(),!f.default.existsSync(k.default.join(t.output,h.Manifest.fileName)))throw new Error(`ERROR: synthesis failed, because app was expected to call 'synth()', but didn't. Thus "${t.output}/${h.Manifest.fileName}"  was not created.`);let n=JSON.parse(f.default.readFileSync(k.default.join(t.output,h.Manifest.fileName)).toString()),o=Object.keys(n.stacks).map(e=>{let a=n.stacks[e],p=k.default.join(t.output,a.synthesizedStackPath),b=JSON.parse(f.default.readFileSync(p).toString());return{...a,workingDirectory:k.default.join(t.output,a.workingDirectory),content:JSON.stringify(b,null,2)}});o.length===0?console.error("ERROR: No Terraform code synthesized."):console.log("Synthesized Terraform code for the following stacks: ",o);let r=o.map(e=>e.name),i=M(k.default.join(t.output,h.Manifest.stacksFolder)).filter(e=>!r.includes(k.default.basename(e)));for(let e of i)f.default.rmSync(e,{recursive:!0});return o}async deploy(t={}){let n=await this.synth(),o=(0,c.getMultipleStacks)(n,t.stackNames,"deploy");t.ignoreMissingStackDependencies||(0,c.checkIfAllDependenciesAreIncluded)(o);let r=new AbortController;this.stacksToRun=o.map(e=>new T.CdktfStack({...t,onUpdate(a){console.log({update:a}),a.type==="waiting for stack approval"&&a.approve()},abortSignal:r.signal,stack:e})),this.stopAllStacksThatCanNotRunWithout=e=>{(0,c.findAllNestedDependantStacks)(this.stacksToRun,e).forEach(a=>a.stop())};let l=t.ignoreMissingStackDependencies?()=>Promise.resolve(this.stacksToRun.filter(e=>e.isPending)[0]):()=>(0,c.getStackWithNoUnmetDependencies)(this.stacksToRun);await this.execute("deploy",l,t);let i=this.stacksToRun.filter(e=>e.isPending);if(i.length>0)throw u.Errors.External(`Some stacks failed to deploy: ${i.map(e=>e.stack.name).join(", ")}. Please check the logs for more information.`)}async destroy(t={}){let n=await this.synth(),o=(0,c.getMultipleStacks)(n,t.stackNames,"destroy");t.ignoreMissingStackDependencies||(0,c.checkIfAllDependantsAreIncluded)(o,n),this.stopAllStacksThatCanNotRunWithout=i=>{let e=this.stacksToRun.find(a=>a.stack.name===i);if(!e)throw u.Errors.Internal(`Could not find stack "${i}" that was stopped`);e.stack.dependencies.forEach(a=>{this.stopAllStacksThatCanNotRunWithout(a);let p=this.stacksToRun.find(b=>b.stack.name===a);if(!p)throw u.Errors.Internal(`Could not find stack "${a}" that was stopped`);p.stop()})},this.stacksToRun=o.map(i=>this.getStackExecutor(i,t));let r=t.ignoreMissingStackDependencies?()=>Promise.resolve(this.stacksToRun.filter(i=>i.currentState!=="done")[0]):()=>(0,c.getStackWithNoUnmetDependants)(this.stacksToRun);await this.execute("destroy",r,t);let l=this.stacksToRun.filter(i=>i.isPending);if(l.length>0)throw u.Errors.External(`Some stacks failed to destroy: ${l.map(i=>i.stack.name).join(", ")}. Please check the logs for more information.`)}async execute(t,n,o){if(o.refreshOnly&&t!=="deploy")throw u.Errors.Internal("Refresh only is only supported on deploy");let r=!o.parallelism||o.parallelism<0?1/0:o.parallelism,l=[];for(await this.initializeStacksToRunInSerial(o.noColor);this.stacksToRun.filter(i=>i.isPending).length>0;){let i=this.stacksToRun.filter(e=>e.isRunning);if(i.length>=r){await Promise.race(i.map(e=>e.currentWorkPromise));continue}try{let e=await n();if(!e)break;let a=t==="deploy"?e.deploy(o):e.destroy(o);l.push(a)}catch(e){console.debug("Encountered an error while awaiting stack to finish",e);let a=this.stacksToRun.filter(p=>p.currentWorkPromise);throw console.debug("Waiting for still running stacks to finish:",a),await Promise.allSettled(a.map(p=>p.currentWorkPromise)),console.debug("Done waiting for still running stacks. All pending work finished"),e}}await(0,u.ensureAllSettledBeforeThrowing)(Promise.all(l),l)}getStackExecutor(t,n={}){return new T.CdktfStack({...n,stack:t,onUpdate(o){console.log({update:o}),o.type==="waiting for stack approval"&&o.approve()},abortSignal:this.abortSignal})}async initializeStacksToRunInSerial(t){await Promise.all(this.stacksToRun.map(n=>n.initalizeTerraform(t)))}};var S=class extends w.TerraformStack{constructor(t,n){super(t,n),new R.provider.AwsProvider(this,"aws",{region:"us-east-1"});let o=new R.AwsTerraformAdapter(this,"adapter");new v.default.Bucket(o,"MyFirstBucket",{bucketName:"my-first-bucket-in-terraform-is-so-epic",versioned:!0})}};async function I(){let s=new w.App;new S(s,"learn-cdktf-aws"),s.synth()}async function W(){await new y({synthFn:I}).deploy()}W();0&&(module.exports={HelloCdkStack});
//# sourceMappingURL=index.cjs.map