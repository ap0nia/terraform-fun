import D from"aws-cdk-lib/aws-s3";import{App as O,TerraformStack as N}from"cdktf";import{AwsTerraformAdapter as E,provider as j}from"@cdktf/aws-cdk";import k from"node:fs";import p from"node:path";import{Manifest as d}from"cdktf";import{Errors as u,ensureAllSettledBeforeThrowing as T}from"@cdktf/commons";import{getMultipleStacks as S,getStackWithNoUnmetDependencies as x,checkIfAllDependantsAreIncluded as A,checkIfAllDependenciesAreIncluded as M,getStackWithNoUnmetDependants as P,findAllNestedDependantStacks as v}from"@cdktf/cli-core/src/lib/helpers/stack-helpers.js";import{CdktfStack as w}from"@cdktf/cli-core";import m from"node:fs";import b from"node:path";function y(a){return m.existsSync(a)?m.readdirSync(a).map(t=>b.join(a,t)).filter(t=>m.lstatSync(t).isDirectory()):[]}function R(){}var C={output:"cdktf.out",codeMakerOutput:".gen"},f=class{stacksToRun=[];stopAllStacksThatCanNotRunWithout=R;hardAbort;abortSignal;synthFn;constructor(t={}){this.synthFn=t.synthFn??R;let i=new AbortController;this.abortSignal=i.signal,this.hardAbort=i.abort.bind(i)}async synth(t=C){if(await this.synthFn(),!k.existsSync(p.join(t.output,d.fileName)))throw new Error(`ERROR: synthesis failed, because app was expected to call 'synth()', but didn't. Thus "${t.output}/${d.fileName}"  was not created.`);let i=JSON.parse(k.readFileSync(p.join(t.output,d.fileName)).toString()),n=Object.keys(i.stacks).map(e=>{let s=i.stacks[e],c=p.join(t.output,s.synthesizedStackPath),h=JSON.parse(k.readFileSync(c).toString());return{...s,workingDirectory:p.join(t.output,s.workingDirectory),content:JSON.stringify(h,null,2)}});n.length===0?console.error("ERROR: No Terraform code synthesized."):console.log("Synthesized Terraform code for the following stacks: ",n);let l=n.map(e=>e.name),o=y(p.join(t.output,d.stacksFolder)).filter(e=>!l.includes(p.basename(e)));for(let e of o)k.rmSync(e,{recursive:!0});return n}async deploy(t={}){let i=await this.synth(),n=S(i,t.stackNames,"deploy");t.ignoreMissingStackDependencies||M(n);let l=new AbortController;this.stacksToRun=n.map(e=>new w({...t,onUpdate(s){console.log({update:s}),s.type==="waiting for stack approval"&&s.approve()},abortSignal:l.signal,stack:e})),this.stopAllStacksThatCanNotRunWithout=e=>{v(this.stacksToRun,e).forEach(s=>s.stop())};let r=t.ignoreMissingStackDependencies?()=>Promise.resolve(this.stacksToRun.filter(e=>e.isPending)[0]):()=>x(this.stacksToRun);await this.execute("deploy",r,t);let o=this.stacksToRun.filter(e=>e.isPending);if(o.length>0)throw u.External(`Some stacks failed to deploy: ${o.map(e=>e.stack.name).join(", ")}. Please check the logs for more information.`)}async destroy(t={}){let i=await this.synth(),n=S(i,t.stackNames,"destroy");t.ignoreMissingStackDependencies||A(n,i),this.stopAllStacksThatCanNotRunWithout=o=>{let e=this.stacksToRun.find(s=>s.stack.name===o);if(!e)throw u.Internal(`Could not find stack "${o}" that was stopped`);e.stack.dependencies.forEach(s=>{this.stopAllStacksThatCanNotRunWithout(s);let c=this.stacksToRun.find(h=>h.stack.name===s);if(!c)throw u.Internal(`Could not find stack "${s}" that was stopped`);c.stop()})},this.stacksToRun=n.map(o=>this.getStackExecutor(o,t));let l=t.ignoreMissingStackDependencies?()=>Promise.resolve(this.stacksToRun.filter(o=>o.currentState!=="done")[0]):()=>P(this.stacksToRun);await this.execute("destroy",l,t);let r=this.stacksToRun.filter(o=>o.isPending);if(r.length>0)throw u.External(`Some stacks failed to destroy: ${r.map(o=>o.stack.name).join(", ")}. Please check the logs for more information.`)}async execute(t,i,n){if(n.refreshOnly&&t!=="deploy")throw u.Internal("Refresh only is only supported on deploy");let l=!n.parallelism||n.parallelism<0?1/0:n.parallelism,r=[];for(await this.initializeStacksToRunInSerial(n.noColor);this.stacksToRun.filter(o=>o.isPending).length>0;){let o=this.stacksToRun.filter(e=>e.isRunning);if(o.length>=l){await Promise.race(o.map(e=>e.currentWorkPromise));continue}try{let e=await i();if(!e)break;let s=t==="deploy"?e.deploy(n):e.destroy(n);r.push(s)}catch(e){console.debug("Encountered an error while awaiting stack to finish",e);let s=this.stacksToRun.filter(c=>c.currentWorkPromise);throw console.debug("Waiting for still running stacks to finish:",s),await Promise.allSettled(s.map(c=>c.currentWorkPromise)),console.debug("Done waiting for still running stacks. All pending work finished"),e}}await T(Promise.all(r),r)}getStackExecutor(t,i={}){return new w({...i,stack:t,onUpdate(n){console.log({update:n}),n.type==="waiting for stack approval"&&n.approve()},abortSignal:this.abortSignal})}async initializeStacksToRunInSerial(t){await Promise.all(this.stacksToRun.map(i=>i.initalizeTerraform(t)))}};var g=class extends N{constructor(t,i){super(t,i),new j.AwsProvider(this,"aws",{region:"us-east-1"});let n=new E(this,"adapter");new D.Bucket(n,"MyFirstBucket",{bucketName:"my-first-bucket-in-terraform-is-so-epic",versioned:!0})}};async function F(){let a=new O;new g(a,"learn-cdktf-aws"),a.synth()}async function z(){await new f({synthFn:F}).deploy()}z();export{g as HelloCdkStack};
//# sourceMappingURL=index.js.map