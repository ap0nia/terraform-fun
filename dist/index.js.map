{"version":3,"sources":["../src/index.ts","../src/cdktf/project.ts","../src/utils/directories.ts"],"sourcesContent":["import { Construct } from \"constructs\";\nimport aws_s3 from 'aws-cdk-lib/aws-s3';\nimport { App, TerraformStack } from \"cdktf\";\nimport { AwsTerraformAdapter, provider } from \"@cdktf/aws-cdk\";\nimport { CdktfProject } from './cdktf/project.js'\n\nexport class HelloCdkStack extends TerraformStack {\n  constructor(scope: Construct, name: string) {\n    super(scope, name);\n\n    new provider.AwsProvider(this, 'aws', { region: 'us-east-1' })\n\n    const awsAdapter = new AwsTerraformAdapter(this, \"adapter\");\n\n    new aws_s3.Bucket(awsAdapter, 'MyFirstBucket', {\n      bucketName: 'my-first-bucket-in-terraform-is-so-epic',\n      versioned: true,\n    });\n  }\n}\n\nasync function synthFn() {\n  const app = new App();\n\n  new HelloCdkStack(app, \"learn-cdktf-aws\");\n\n  app.synth();\n}\n\nasync function start() {\n  const project = new CdktfProject({ synthFn });\n\n  await project.deploy()\n\n  // await project.destroy()\n}\n\nstart()\n","import fs from 'node:fs'\nimport path from 'node:path'\nimport { Manifest, type StackManifest, type TerraformStackMetadata } from \"cdktf\";\nimport { Errors, ensureAllSettledBeforeThrowing } from '@cdktf/commons'\nimport {\n  getMultipleStacks,\n  getStackWithNoUnmetDependencies,\n  checkIfAllDependantsAreIncluded,\n  checkIfAllDependenciesAreIncluded,\n  getStackWithNoUnmetDependants,\n  findAllNestedDependantStacks,\n} from '@cdktf/cli-core/src/lib/helpers/stack-helpers.js'\nimport { CdktfStack } from '@cdktf/cli-core';\nimport { getDirectories } from '../utils/directories.js';\n\nfunction noop() { }\n\ninterface SynthesizedStack extends StackManifest {\n  content: string;\n}\n\ninterface ManifestJson {\n  version: string;\n  stacks: Record<string, StackManifest>;\n}\n\ninterface SynthesizedStackMetadata {\n  \"//\"?: Record<string, TerraformStackMetadata>\n}\n\ntype ExecutionMethod = 'deploy' | 'destroy'\n\ntype CdktfStackMiddleware = () => Promise<CdktfStack | undefined>\n\nconst CONFIG_DEFAULTS = {\n  output: \"cdktf.out\",\n  codeMakerOutput: \".gen\",\n}\n\nexport type MultipleStackOptions = {\n  stackNames?: string[];\n};\n\nexport type AutoApproveOptions = {\n  autoApprove?: boolean;\n};\n\nexport type MutationOptions = MultipleStackOptions & AutoApproveOptions & {\n  refreshOnly?: boolean;\n  ignoreMissingStackDependencies?: boolean;\n  parallelism?: number;\n  terraformParallelism?: number;\n  vars?: string[];\n  varFiles?: string[];\n  noColor?: boolean;\n  migrateState?: boolean;\n};\n\ninterface CdktfProjectOptions {\n  /**\n   * A function that will run and generate an output JSON.\n   */\n  synthFn?: () => unknown | Promise<unknown>;\n}\n\n/**\n * A simplfied, minimal adaptation of the official class.\n * {@link https://github.com/hashicorp/terraform-cdk/blob/main/packages/%40cdktf/cli-core/src/lib/cdktf-project.ts}\n */\nexport class CdktfProject {\n  public stacksToRun: CdktfStack[] = [];\n\n  private stopAllStacksThatCanNotRunWithout: (stackName: string) => void = noop\n\n  public hardAbort: () => void;\n\n  private abortSignal: AbortSignal;\n\n  private synthFn: () => unknown | Promise<unknown>;\n\n  constructor(options: CdktfProjectOptions = {}) {\n    this.synthFn = options.synthFn ?? noop;\n\n    const ac = new AbortController();\n    this.abortSignal = ac.signal;\n    this.hardAbort = ac.abort.bind(ac);\n  }\n\n  async synth(opts = CONFIG_DEFAULTS) {\n    await this.synthFn()\n\n    if (!(fs.existsSync(path.join(opts.output, Manifest.fileName)))) {\n      throw new Error(\n        `ERROR: synthesis failed, because app was expected to call 'synth()', but didn't. Thus \"${opts.output}/${Manifest.fileName}\"  was not created.`\n      );\n    }\n\n    const manifest: ManifestJson = JSON.parse(\n      fs.readFileSync(path.join(opts.output, Manifest.fileName)).toString()\n    );\n\n    const stacks: SynthesizedStack[] = Object.keys(manifest.stacks).map(stackName => {\n      const stack = manifest.stacks[stackName];\n\n      const filePath = path.join(opts.output, stack.synthesizedStackPath);\n\n      const jsonContent: SynthesizedStackMetadata = JSON.parse(\n        fs.readFileSync(filePath).toString()\n      );\n\n      return {\n        ...stack,\n        workingDirectory: path.join(opts.output, stack.workingDirectory),\n        content: JSON.stringify(jsonContent, null, 2),\n      }\n    })\n\n    if (stacks.length === 0) {\n      console.error(\"ERROR: No Terraform code synthesized.\");\n    } else {\n      console.log(\"Synthesized Terraform code for the following stacks: \", stacks);\n    }\n\n    const stackNames = stacks.map((s) => s.name);\n\n    const existingDirectories = getDirectories(path.join(opts.output, Manifest.stacksFolder));\n\n    const orphanedDirectories = existingDirectories.filter(\n      (e) => !stackNames.includes(path.basename(e))\n    );\n\n    for (const orphanedDirectory of orphanedDirectories) {\n      fs.rmSync(orphanedDirectory, { recursive: true });\n    }\n\n    return stacks\n  }\n\n  async deploy(opts: MutationOptions = {}) {\n    const stacks = await this.synth();\n\n    const stacksToRun = getMultipleStacks(stacks, opts.stackNames, \"deploy\");\n\n    if (!opts.ignoreMissingStackDependencies) {\n      checkIfAllDependenciesAreIncluded(stacksToRun);\n    }\n\n    const abortController = new AbortController();\n\n    this.stacksToRun = stacksToRun.map((stack) => {\n      return new CdktfStack({\n        ...opts,\n        onUpdate(update) {\n          console.log({ update })\n          if (update.type === 'waiting for stack approval') {\n            update.approve()\n          }\n        },\n        abortSignal: abortController.signal,\n        stack,\n      });\n    });\n\n    this.stopAllStacksThatCanNotRunWithout = (stackName: string) => {\n      findAllNestedDependantStacks(this.stacksToRun, stackName).forEach((stack) => stack.stop());\n    };\n\n    const next = opts.ignoreMissingStackDependencies\n      ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.isPending)[0])\n      : () => getStackWithNoUnmetDependencies(this.stacksToRun);\n\n\n    await this.execute(\"deploy\", next, opts);\n\n    const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);\n\n    if (unprocessedStacks.length > 0) {\n      throw Errors.External(\n        `Some stacks failed to deploy: ${unprocessedStacks\n          .map((s) => s.stack.name)\n          .join(\", \")}. Please check the logs for more information.`\n      );\n    }\n  }\n\n  public async destroy(opts: MutationOptions = {}) {\n    const stacks = await this.synth();\n\n    const stacksToRun = getMultipleStacks(stacks, opts.stackNames, \"destroy\");\n\n    if (!opts.ignoreMissingStackDependencies) {\n      checkIfAllDependantsAreIncluded(stacksToRun, stacks);\n    }\n\n    this.stopAllStacksThatCanNotRunWithout = (stackName: string) => {\n      const stackExecutor = this.stacksToRun.find((s) => s.stack.name === stackName);\n\n      if (!stackExecutor) {\n        throw Errors.Internal(\n          `Could not find stack \"${stackName}\" that was stopped`\n        );\n      }\n\n      stackExecutor.stack.dependencies.forEach((dependant) => {\n        this.stopAllStacksThatCanNotRunWithout(dependant);\n\n        const dependantStack = this.stacksToRun.find(\n          (s) => s.stack.name === dependant\n        );\n\n        if (!dependantStack) {\n          throw Errors.Internal(\n            `Could not find stack \"${dependant}\" that was stopped`\n          );\n        }\n\n        dependantStack.stop();\n      });\n    };\n\n    this.stacksToRun = stacksToRun.map((stack) =>\n      this.getStackExecutor(stack, opts)\n    );\n\n    const next = opts.ignoreMissingStackDependencies\n      ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.currentState !== \"done\")[0])\n      : () => getStackWithNoUnmetDependants(this.stacksToRun);\n\n    await this.execute(\"destroy\", next, opts);\n\n    const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);\n\n    if (unprocessedStacks.length > 0) {\n      throw Errors.External(\n        `Some stacks failed to destroy: ${unprocessedStacks\n          .map((s) => s.stack.name)\n          .join(\", \")}. Please check the logs for more information.`\n      );\n    }\n  }\n\n  async execute(method: ExecutionMethod, next: CdktfStackMiddleware, opts: MutationOptions) {\n    // We only support refresh only on deploy, a bit of a leaky abstraction here\n    if (opts.refreshOnly && method !== \"deploy\") {\n      throw Errors.Internal(`Refresh only is only supported on deploy`);\n    }\n\n    const maxParallelRuns = !opts.parallelism || opts.parallelism < 0 ? Infinity : opts.parallelism;\n\n    const allExecutions: Promise<unknown>[] = [];\n\n    await this.initializeStacksToRunInSerial(opts.noColor);\n\n    while (this.stacksToRun.filter((stack) => stack.isPending).length > 0) {\n      const runningStacks = this.stacksToRun.filter((stack) => stack.isRunning);\n\n      if (runningStacks.length >= maxParallelRuns) {\n        await Promise.race(runningStacks.map((s) => s.currentWorkPromise));\n        continue;\n      }\n\n      try {\n        const nextRunningExecutor = await next();\n\n        if (!nextRunningExecutor) {\n          // In this case we have no pending stacks, but we also can not find a new executor\n          break;\n        }\n\n        const promise = method === \"deploy\"\n          ? nextRunningExecutor.deploy(opts)\n          : nextRunningExecutor.destroy(opts);\n\n        allExecutions.push(promise);\n      } catch (e) {\n        // await next() threw an error because a stack failed to apply/destroy\n        // wait for all other currently running stacks to complete before propagating that error\n        console.debug(\"Encountered an error while awaiting stack to finish\", e);\n        const openStacks = this.stacksToRun.filter((ex) => ex.currentWorkPromise);\n        console.debug(\"Waiting for still running stacks to finish:\", openStacks);\n        await Promise.allSettled(openStacks.map((ex) => ex.currentWorkPromise));\n        console.debug(\"Done waiting for still running stacks. All pending work finished\");\n        throw e;\n      }\n    }\n\n    // We end the loop when all stacks are started, now we need to wait for them to be done.\n    // We wait for all work to finish even if one of the promises threw an error.\n    await ensureAllSettledBeforeThrowing(Promise.all(allExecutions), allExecutions);\n  }\n\n  public getStackExecutor(stack: SynthesizedStack, opts: AutoApproveOptions = {}) {\n    return new CdktfStack({\n      ...opts,\n      stack,\n      onUpdate(update) {\n        console.log({ update })\n        if (update.type === 'waiting for stack approval') {\n          update.approve()\n        }\n      },\n      abortSignal: this.abortSignal,\n    });\n  }\n\n  // Serially run terraform init to prohibit text file busy errors for the cache files\n  private async initializeStacksToRunInSerial(noColor?: boolean): Promise<void> {\n    await Promise.all(this.stacksToRun.map((stack) => stack.initalizeTerraform(noColor)));\n  }\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nexport function getDirectories(source: string) {\n  return fs.existsSync(source)\n    ? fs\n      .readdirSync(source)\n      .map((name) => path.join(source, name))\n      .filter(source => fs.lstatSync(source).isDirectory())\n    : [];\n};\n\n"],"mappings":"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","names":["aws_s3","App","TerraformStack","AwsTerraformAdapter","provider","fs","path","Manifest","Errors","ensureAllSettledBeforeThrowing","getMultipleStacks","getStackWithNoUnmetDependencies","checkIfAllDependantsAreIncluded","checkIfAllDependenciesAreIncluded","getStackWithNoUnmetDependants","findAllNestedDependantStacks","CdktfStack","fs","path","getDirectories","source","name","noop","CONFIG_DEFAULTS","CdktfProject","options","ac","opts","fs","path","Manifest","manifest","stacks","stackName","stack","filePath","jsonContent","stackNames","s","orphanedDirectories","getDirectories","orphanedDirectory","stacksToRun","getMultipleStacks","checkIfAllDependenciesAreIncluded","abortController","CdktfStack","update","findAllNestedDependantStacks","next","getStackWithNoUnmetDependencies","unprocessedStacks","executor","Errors","checkIfAllDependantsAreIncluded","stackExecutor","dependant","dependantStack","getStackWithNoUnmetDependants","method","maxParallelRuns","allExecutions","runningStacks","nextRunningExecutor","promise","openStacks","ex","ensureAllSettledBeforeThrowing","noColor","HelloCdkStack","TerraformStack","scope","name","provider","awsAdapter","AwsTerraformAdapter","aws_s3","synthFn","app","App","start","CdktfProject"]}